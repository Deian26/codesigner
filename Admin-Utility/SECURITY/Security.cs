using Admin_Utility.UTILITY;
using System;
using System.CodeDom;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management;
using System.Runtime.Versioning;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using Windows.Data.Xml.Dom;
using Windows.Devices.Geolocation;
using static Admin_Utility.Security;

namespace Admin_Utility
{
    /// <summary>
    /// Handles security-relevant avtions
    /// </summary>
    [SupportedOSPlatform("windows")]
    internal static class Security
    {
        private static string GeneratorId { get; set; } = null;

        public static readonly string RSA_KEY_CONTAINER_NAME = "RSA_KEY_CONTAINER";
        private static readonly int AES_KEY_SIZE = 128;

        internal enum AccessLevel { NONE = 0, ADMIN = 1, USER = 2 , ADMIN_WORKSTATION = 3};
        
        private static List<Token> CrtUserGeneratedTokens = new List<Token>(); // list of tokens generated by the current user, across all sessions

        internal static string[] TokenExpirationLimits = // seconds
        {
            Token.MIN_EXPIRATION_LIMIT.ToString(),
            ((int)Token.MAX_EXPIRATION_LIMIT/2).ToString(),
            Token.MAX_EXPIRATION_LIMIT.ToString()

        };
        /// <summary>
        /// Defines a token; fields are separeted by 'Token.FIELD_SEPARATOR'
        /// </summary>
        internal class Token
        {
            internal const char FIELD_SEPARATOR = '-';
            internal const int MIN_EXPIRATION_LIMIT = 60; // the minimum number of seconds from a token's generation until it expires
            internal const int MAX_EXPIRATION_LIMIT = 21600; // the maximum time expiration limit (seconds)

            internal DateTime TS { get; } = DateTime.MaxValue; // time stamp
            internal Security.AccessLevel ACCESS_LEVEL { get; } = Security.AccessLevel.NONE;
            private string ID { get; } = null; // code used to verify the validity of the token
            private int EXPIRATION_LIMIT_SEC = 0; // the number of seconds from the token's generation until it expires and can no longer be used
            private bool VALID { get; } = false; // valid generation flag
            /// <summary>
            /// Generates a new token which grants the specified access level
            /// </summary>
            /// <param name="accessLevel">Access to be provided by the token</param>
            /// <param name="expirationLimitSec">Expiration limit, in seconds, for this token (since its generation)</param>
            internal Token(string accessLevel, int expirationLimitSec)
            {
                // assign fields
                if (Enum.IsDefined(typeof(Security.AccessLevel), accessLevel) == false) //=> unrecognized access level code
                {
                    MessageBox.Show($"Access level code {accessLevel} is undefined!", "Unrecognized Access Level Code", MessageBoxButtons.OK, MessageBoxIcon.Error);

                    this.VALID = false;
                }else if (expirationLimitSec < Token.MIN_EXPIRATION_LIMIT)
                {
                    MessageBox.Show($"The expiration time limit {expirationLimitSec}s is lower than the minimum of {Token.MIN_EXPIRATION_LIMIT}s !", "Invalid Token Expiration Limit", MessageBoxButtons.OK, MessageBoxIcon.Error);

                    this.VALID = false;
                }else if (expirationLimitSec > Token.MAX_EXPIRATION_LIMIT)
                {
                    MessageBox.Show($"The expiration time limit {expirationLimitSec}s is higher than the maximum of {Token.MAX_EXPIRATION_LIMIT}s !", "Invalid Token Expiration Limit", MessageBoxButtons.OK, MessageBoxIcon.Error);

                    this.VALID = false;
                }
                else // valid token details
                {
                    this.TS = DateTime.UtcNow;

                    this.ID = Security.GenerateHash(this.TS.ToString() + Security.GeneratorId);

                    this.ACCESS_LEVEL = (Security.AccessLevel)Enum.Parse(typeof(Security.AccessLevel),accessLevel);

                    this.EXPIRATION_LIMIT_SEC = expirationLimitSec;

                    this.VALID = true;

                    // add the token to the list of tokens generated by the current user
                    Security.AddGeneratedToken(this);
                }

            }

            /// <summary>
            /// Returns the string representation of the current Token object
            /// </summary>
            /// <returns>Token string or null, if the token is invalid</returns>
            internal string ToString()
            {
                string tokenString = null;

                if (this.VALID == true)
                {
                    tokenString =
                            Convert.ToBase64String(Encoding.UTF8.GetBytes(this.ID))                         + Token.FIELD_SEPARATOR +   // field 0
                            Convert.ToBase64String(Encoding.UTF8.GetBytes(this.TS.ToString()))              + Token.FIELD_SEPARATOR +   // field 1
                            Convert.ToBase64String(Encoding.UTF8.GetBytes(this.ACCESS_LEVEL.ToString()))    + Token.FIELD_SEPARATOR +   // field 2
                            Convert.ToBase64String(Encoding.UTF8.GetBytes(this.EXPIRATION_LIMIT_SEC.ToString()));                       // field 3
                }

                return tokenString;
            }
        
        }

        /// <summary>
        /// Adds the given token to the list of tokens generated by the current user
        /// </summary>
        /// <param name="token">The token to add to the list</param>
        public static void AddGeneratedToken(Token token)
        {
            if(token != null)
            {
                Security.CrtUserGeneratedTokens.Add(token);

                // add the token to the control displaying tokens generated by the current user
                Start.U0.addTokenNode(token);
            }
        }

        /// <summary>
        /// Generates the hash for the provided input text
        /// </summary>
        /// <param name="input">Text to be hashed</param>
        /// <returns>Hashed text or null</returns>
        internal static string GenerateHash(string input)
        {
            string cipherText = null;
            try
            {
                SHA256 sha256 = SHA256.Create();
                
                cipherText = Security.ToByteString(sha256.ComputeHash(Encoding.UTF8.GetBytes(input)));
                
                sha256.Clear();
            }
            catch (Exception e)
            {
                MessageBox.Show($"Details: {e.Message}","Hash Generation Error",MessageBoxButtons.OK,MessageBoxIcon.Error);
            }

            return cipherText;
        }

        /// <summary>
        /// Generates the machine's generator base ID
        /// </summary>
        /// <param name="developmentId">if true, the development generator id will be used</param>
        /// <returns>The machine's generator ID</returns>
        internal static string GetGeneratorId(bool developmentId)
        {
            //=// Generate ID
            string id = null;

            if (developmentId == true) //=> use development generator ID (not usable for released versions of the target application)
            {
                id = "DEVELOPMENT";
            }
            else //=> use the current machine's UUID (hashed)
            {
                // read the generated GUID for this computer, if it exists
                string hashedGuid = null;

                if (File.Exists(GeneralPaths.SEC_HASHED_GUID_FILE_PATH) == true)
                {
                    string encryptedFileText = File.ReadAllText(GeneralPaths.SEC_HASHED_GUID_FILE_PATH);
                    id = Convert.ToBase64String(ProtectedData.Unprotect(Convert.FromBase64String(encryptedFileText), null, DataProtectionScope.CurrentUser));
                }
                else // generate a new GUID and store it on the disk
                {
                    Guid guid = Guid.NewGuid();
                    byte[] byteHashedGuid;

                    using (SHA256 sha256 = SHA256.Create())
                    {
                        byteHashedGuid = sha256.ComputeHash(guid.ToByteArray());
                        id = Convert.ToBase64String(byteHashedGuid);
                    }

                    // store the hashed, encrypted GUID
                    File.WriteAllText(GeneralPaths.SEC_HASHED_GUID_FILE_PATH, Convert.ToBase64String(ProtectedData.Protect(byteHashedGuid, null, DataProtectionScope.CurrentUser)));
                }
            }

            Security.GeneratorId = Security.GenerateHash(id); //=> store ID in memory
            

            return Security.GeneratorId;
        }
        
        /// <summary>
        /// Generates and returns the byte-string corresponding to the given byte array
        /// </summary>
        /// <param name="bytes">Array to be converted</param>
        /// <returns>A hexadecimal string representing the input byte array</returns>
        internal static string ToByteString(byte[] bytes)
        {
            string byteString = "";
            
            foreach (byte b in bytes)
            {
                byteString += b.ToString().PadLeft(2,'0');
            }

            return byteString;
        }

        /// <summary>
        /// Generates a new token, with the specified access level and returns its string representation
        /// </summary>
        /// <param name="accessLevel">Access to be granted</param>
        /// <param name="expirationLimitSec">Expiration limit, in seconds, for the token, since its generation</param>
        /// <returns>The generated token object or null, if an error occurs</returns>
        internal static Security.Token GenerateToken(string accessLevel, string expirationLimitSec)
        {
            int intExpirationLimitSec = 0;

            if(accessLevel.Equals(string.Empty)) // valid checked since it is passed to the Token generator; the expiration limit is checked in more detail when the token is generated
            {
                MessageBox.Show($"Invalid access level selected for token generation: {accessLevel}","Invalid access level selected",MessageBoxButtons.OK, MessageBoxIcon.Error);
                return null;
            }
            if(Int32.TryParse(expirationLimitSec, out intExpirationLimitSec) == false)
            {
                MessageBox.Show($"Invalid access level selected for token generation: {accessLevel}", "Invalid access level selected", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return null;
            }

            Token token = new Token(accessLevel, intExpirationLimitSec); //=> generate new token

            // store the token generation details on the disk
            Security.StoreToken(token);

            // return token string
            if (token != null)
            {
                return token;
            }
            else
            {
                return null;
            }
            
        }

        #region enc-dec

        #region RSA
        /// <summary>
        /// Decrypts the given RSA-encrypted text
        /// </summary>
        /// <param name="cipherText">Text to decrypt</param>
        /// <returns>Plain text as a Base64 encoded string</returns>
        internal static string RsaDecrypt(string cipherText)
        {
            string plainText = null;
            try
            {
                CspParameters cspParms = new CspParameters();
                cspParms.KeyContainerName = Security.RSA_KEY_CONTAINER_NAME;

                using (RSA rsa = new RSACryptoServiceProvider(cspParms))
                {
                    plainText = Convert.ToBase64String(rsa.Decrypt(Convert.FromBase64String(cipherText),RSAEncryptionPadding.Pkcs1));
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Could not decrypt the RSA-encrypted text: {ex.Message}", "Error Decrypting Text", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            return plainText;
        }

        /// <summary>
        /// Creates and stores a set of RSA parameters used for encrypting communication sent to the Admin-Utility
        /// </summary>
        /// <return>The RSA public key hexadecimal-string</return>
        public static string CreateAndStoreRsaParameters()
        {
            CspParameters cspParms = new CspParameters();
            cspParms.KeyContainerName = Security.RSA_KEY_CONTAINER_NAME;
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(cspParms); // store public key
            return Convert.ToBase64String(rsa.ExportRSAPublicKey()); // export public encryption key

        }

        #endregion

        #region AES
        /// <summary>
        /// Decrypts the given AES-encrypted text
        /// </summary>
        /// <param name="cipherText">The text to decrypt; must be a Base64 encoded hexadecimal string</param>
        /// <param name="stringKey">The AES key used to decrypt the text; must be a Base64 encoded hexadecimal string</param>
        /// <param name="stringIv">AES IV as a Base64 encoded string</param>
        /// <returns>The plain text</returns>
        public static string AesDecrypt(string cipherText, string stringKey, string stringIv)
        {
            string plainText = null;
            
            try
            {
                byte[] byteKey = Convert.FromBase64String(stringKey); // decode key
                byte[] byteIv = Convert.FromBase64String(stringIv); // decode IV

                // create an AES object
                using (Aes aes = Aes.Create())
                {
                    aes.KeySize = Security.AES_KEY_SIZE;
                    aes.Key = byteKey;
                    aes.IV = byteIv;

                    using (MemoryStream inputStream = new MemoryStream(Convert.FromBase64String(cipherText))) // read the 
                    {
                        using (CryptoStream cryptoStream = new CryptoStream(inputStream, aes.CreateDecryptor(aes.Key,aes.IV), CryptoStreamMode.Read))
                        {
                            using (StreamReader streamReader = new StreamReader(cryptoStream))
                            {
                                plainText = streamReader.ReadToEnd();
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Could not decrypt the AES-encrypted text: {ex.Message}", "AES decrypting error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            return plainText;
        }

        #endregion
        /// <summary>
        /// Decrypts the AES-encrypted text stored at reportPath (uses an RSA-encrypted key, stored together with the AES-encrypted data)
        /// </summary>
        /// <param name="reportPath">Encrypted file path</param>
        /// <returns>The decrypted text</returns>
        public static string AesDecryptFile(string reportPath)
        {
            string plainText = null;

            try
            {
                // open the file and read the contents
                string[] reportFileContents = File.ReadAllLines(reportPath);

                // get and decrypt the AES key stored with the report (RSA-encrypted)
                string aesKey = Security.RsaDecrypt(reportFileContents[0]); // the AES key is stored on the first line of the file
                string aesIv = Security.RsaDecrypt(reportFileContents[1]); // the AES IV

                // concatenate the other lines
                string cipherTextReport = "";

                for (int i = 2; i < reportFileContents.Length; i++)
                {
                    cipherTextReport += reportFileContents[i];
                }

                // decrypt the report (AES)
                plainText = Security.AesDecrypt(cipherTextReport, aesKey, aesIv);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Could not decrypt the diagnostic report: {ex.Message}","Error decrypting report", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            return plainText;
        }

        /// <summary>
        /// Encrypts the given data for storage (only the user that encrypted the data can decrypt it)
        /// </summary>
        /// <param name="plainText">Text to encrypt</param>
        /// <returns>Encrypted text (can only be decrypted by the user that encrypted it)</returns>
        public static string EncryptForUser(string plainText)
        {
            string cipherText = null;
            try
            {
                cipherText = Convert.ToBase64String(ProtectedData.Protect(
                        Encoding.UTF8.GetBytes(plainText),
                        Encoding.UTF8.GetBytes(Security.GetGeneratorId(false)),
                        DataProtectionScope.CurrentUser
                        ));
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Could not encrypt data for user: {ex.Message}", "Error encrypting data", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            return cipherText;
        }

        /// <summary>
        /// Decrypts the given text, for the current user
        /// </summary>
        /// <param name="cipherText">The text to decrypt</param>
        /// <returns>The plain text corresponding to the cipher text</returns>
        public static string DecryptForUser(string cipherText)
        {
            string plainText = null;
            try
            {
                plainText = Encoding.UTF8.GetString(
                    ProtectedData.Unprotect(
                        Convert.FromBase64String(cipherText),
                        Encoding.UTF8.GetBytes(Security.GetGeneratorId(false)),
                        DataProtectionScope.CurrentUser
                        )
                    );
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Could not decrypt data about the current user: {ex.Message}", "Error decrypting data", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            return plainText;
        }

        #endregion


        #region storage
        /// <summary>
        /// Stores the provided token string locally, in a separate, encrypted file
        /// </summary>
        /// <param name="token">Token to be stored</param>
        public static void StoreToken(Token token)
        {
            try
            {
                XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                xmlWriterSettings.Indent = true;
                xmlWriterSettings.Encoding = Encoding.UTF8;
                xmlWriterSettings.IndentChars = "\t";
                xmlWriterSettings.NewLineChars = "\r\n";

                StringBuilder xmlText = new StringBuilder();
                XmlWriter xmlWriter = XmlWriter.Create(xmlText, xmlWriterSettings);

                xmlWriter.WriteStartDocument();
                xmlWriter.WriteStartElement("token");

                // store user details
                xmlWriter.WriteAttributeString("token-access-level", Enum.GetName(token.ACCESS_LEVEL));
                xmlWriter.WriteAttributeString("token-ts", token.TS.ToString());

                xmlWriter.WriteAttributeString("user-name",Utility.GetSession().UserName);
                xmlWriter.WriteAttributeString("user-access-level",Enum.GetName(Utility.GetSession().AccessLevel));

                // store token
                xmlWriter.WriteAttributeString("token",token.ToString());

                xmlWriter.WriteEndElement();
                xmlWriter.WriteEndDocument();

                xmlWriter.Close();

                // encrypt token string
                string encData = Security.EncryptForUser(xmlText.ToString());

                // create the folder used to store the tokens generated by the current user, if it does not exist
                string generatedTokensFolderPath = Path.Combine(Utility.GetSession().UserLocalFolder, GeneralPaths.SEC_GENERATED_TOKENS_SUBDIR_NAME);

                if (Directory.Exists(generatedTokensFolderPath) == false)
                {
                    Directory.CreateDirectory(generatedTokensFolderPath);
                }

                // store the the data in a file, locally (the filename represents the number of ticks corresponding to the UTC timestamp of when the file eas generated)
                File.WriteAllText(
                    Path.Combine(Utility.GetSession().UserLocalFolder, GeneralPaths.SEC_GENERATED_TOKENS_SUBDIR_NAME, DateTime.UtcNow.Ticks.ToString()+GeneralPaths.GENERATED_TOKEN_FILE_EXT),
                    encData);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Could not store token locally: {ex.Message}","Error storing token", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
        #endregion
    }
}
